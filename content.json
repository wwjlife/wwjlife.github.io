[{"title":"Markdown教程","date":"2017-01-07T07:38:21.000Z","path":":/title/","text":"欢迎使用 Cmd Markdown 编辑阅读器 我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，Cmd Markdown 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown： 整理知识，学习笔记 发布日记，杂文，所见所想 撰写发布技术文稿（代码支持） 撰写发布学术论文（LaTeX 公式支持） 除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载： Windows/Mac/Linux 全平台客户端 请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 新文稿 或者使用快捷键 Ctrl+Alt+N。 什么是 MarkdownMarkdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，粗体 或者 斜体 某些文字，更棒的是，它还可以 1. 制作一份待办事宜 Todo 列表 [ ] 支持以 PDF 格式导出文稿 [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 [x] 新增 Todo 列表功能 [x] 修复 LaTex 公式渲染问题 [x] 新增 LaTex 公式编号功能 2. 书写一个质能守恒公式[^LaTeX]$$E=mc^2$$ 3. 高亮一段代码[^code]1234567@requires_authorizationclass SomeClass: passif __name__ == '__main__': # A comment print 'hello world' 4. 高效绘制 流程图12345678st=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 5. 高效绘制 序列图123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 6. 高效绘制 甘特图12345678910111213title 项目开发流程section 项目确定 需求分析 :a1, 2016-06-22, 3d 可行性报告 :after a1, 5d 概念验证 : 5dsection 项目实施 概要设计 :2016-07-05 , 5d 详细设计 :2016-07-08, 10d 编码 :2016-07-15, 10d 测试 :2016-07-22, 5dsection 发布验收 发布: 2d 验收: 3d 7. 绘制表格 项目 价格 数量 计算机 \\$1600 5 手机 \\$12 12 管线 \\$1 234 8. 更详细语法说明想要查看更详细的语法说明，可以参考我们准备的 Cmd Markdown 简明语法手册，进阶用户可以参考 Cmd Markdown 高阶语法手册 了解更多高级功能。 总而言之，不同于其它 所见即所得 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。 什么是 Cmd Markdown您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 编辑/发布/阅读 Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。 1. 实时同步预览我们将 Cmd Markdown 的主界面一分为二，左边为编辑区，右边为预览区，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！ 2. 编辑工具栏也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 编辑区 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。 3. 编辑模式完全心无旁骛的方式编辑文字：点击 编辑工具栏 最右侧的拉伸按钮或者按下 Ctrl + M，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！ 4. 实时的云端文稿为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 编辑工具栏 的最右侧提示 已保存 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。 5. 离线模式在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。 6. 管理工具栏为了便于管理您的文稿，在 预览区 的顶部放置了如下所示的 管理工具栏： 通过管理工具栏可以： 发布：将当前的文稿生成固定链接，在网络上发布，分享 新建：开始撰写一篇新的文稿 删除：删除当前的文稿 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地 列表：所有新增和过往的文稿都可以在这里查看、操作 模式：切换 普通/Vim/Emacs 编辑模式 7. 阅读工具栏 通过 预览区 右上角的 阅读工具栏，可以查看当前文稿的目录并增强阅读体验。 工具栏上的五个图标依次为： 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落 视图：互换左边编辑区和右边预览区的位置 主题：内置了黑白两种模式的主题，试试 黑色主题，超炫！ 阅读：心无旁骛的阅读模式提供超一流的阅读体验 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境 8. 阅读模式在 阅读工具栏 点击 或者按下 Ctrl+Alt+M 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。 9. 标签、分类和搜索在编辑区任意行首位置输入以下格式的文字可以标签当前文档： 标签： 未分类 标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示： 10. 文稿发布和分享在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 (Ctrl+Alt+P) 发布这份文档给好友吧！ 再一次感谢您花费时间阅读这份欢迎稿，点击 (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！ 作者 @ghosert2016 年 07月 07日 [^LaTeX]: 支持 LaTeX 编辑显示支持，例如：$\\sum_{i=1}^n a_i=0$， 访问 MathJax 参考更多使用方法。 [^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，四十一种主流编程语言。","tags":[{"name":"随笔","slug":"随笔","permalink":"https://github.com/wwjlife/tags/随笔/"},{"name":"游记","slug":"游记","permalink":"https://github.com/wwjlife/tags/游记/"},{"name":"吃货","slug":"吃货","permalink":"https://github.com/wwjlife/tags/吃货/"},{"name":"教程","slug":"教程","permalink":"https://github.com/wwjlife/tags/教程/"}]},{"title":"String","date":"2016-02-24T13:21:21.000Z","path":":/title/","text":"###String String一旦被赋值，便不能更改其指向的字符对象，如果更改，则会指向一个新的字符对象。 当String的变量作为参数传递到函数中，即使函数中改变了它的值，但对函数外是没有影响。（这个是String的特例，其他引用类型一般都会产生影响的） ###StringBuffer ####StringBuffer的构造函数 StringBuffer() StringBuffer(int size) StringBuffer(String str) StringBuffer(CharSequence chars) ####length()和capacity()length()计算StringBuffer当前长度,而整个可分配空间通过capacity()方法得到。 ####ensureCapacity() 设置缓冲区的大小void ensureCapacity(int capacity) ####setLength() 设置缓冲区的长度void setLength(int len) charAt()和setCharAt()char charAt(int where)void setCharAt(int where,char ch) ####getChars()void getChars(int sourceStart,int sourceEnd,char target[],int targetStart) ####append() 可把任何类型数据的字符串表示连接到调用它的StringBuffer对象的末尾。例：int a=42;StringBuffer sb=new StringBuffer(40);String s=sb.append(”a=”).append(a).append(”!”).toString(); ####insert() 插入字符串StringBuffer insert(int index,String str)StringBuffer insert(int index,char ch)StringBuffer insert(int index,Object obj)index指定将字符串插入到StringBuffer对象中的位置的下标。 ####reverse() 颠倒StringBuffer对象中的字符StringBuffer reverse() ####delete()和deleteCharAt() 删除字符StringBuffer delete(int startIndex,int endIndex)StringBuffer deleteCharAt(int loc) ####replace() 替换StringBuffer replace(int startIndex,int endIndex,String str) ####substring() 截取子串String substring(int startIndex)String substring(int startIndex,int endIndex) ###字符串转数字的函数【原文出处】 ####转换字符串为数字12345678/** 转换字符串为数字 */public static int strToInt(String value, int defaultValue) &#123; try &#123; return Integer.valueOf(value); &#125; catch (Exception e) &#123; return defaultValue; &#125; &#125; ####转换字符串为数字 12345678/** 转换字符串为数字 */public static long strToInt(String value, long defaultValue) &#123; try &#123; return Long.valueOf(value); &#125; catch (Exception e) &#123; return defaultValue; &#125; &#125; ####转换16进制字符串为数字12345678/** 转换16进制字符串为数字 */public static int hexToInt(String value, int defaultValue) &#123; try &#123; return Integer.parseInt(value, 16); &#125; catch (Exception e) &#123; return defaultValue; &#125; &#125; ####转换16进制字符串为数字12345678/** 转换16进制字符串为数字 */public static long hexToInt(String value, long defaultValue) &#123; try &#123; return Long.parseLong(value, 16); &#125; catch (Exception e) &#123; return defaultValue; &#125; &#125; ####转换字符串为数字12345678/** 转换字符串为数字 */public static float strToFloat(String value, float defaultValue) &#123; try &#123; return Float.valueOf(value); &#125; catch (Exception e) &#123; return defaultValue; &#125; &#125; ####转换字符串为数字12345678/** 转换字符串为数字 */public static double strToDouble(String value, double defaultValue) &#123; try &#123; return Double.valueOf(value); &#125; catch (Exception e) &#123; return defaultValue; &#125; &#125;","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/wwjlife/tags/Android/"},{"name":"String","slug":"String","permalink":"https://github.com/wwjlife/tags/String/"}]},{"title":"TextView／EditText","date":"2016-02-24T13:21:21.000Z","path":":/title/","text":"##TextView ###常用 android:singleLine设置单行显示 android:textColor设置文本颜色 android:textColorLink文字链接的颜色. android:textScaleX设置文字之间间隔，默认为1.0f android:textColorHighlight被选中文字的底色，默认为蓝色 android:scrollHorizontally设置文本超出TextView的宽度的情况下，是否出现横拉条。 android:hintText为空时显示的文字提示信息 android:textColorHint设置提示信息文字的颜色，默认为灰色。与hint一起使用。 ###不常用 ####android:cursorVisible设定光标为显示/隐藏，默认显示。 ####android:ellipsize设置当文字过长时,该控件该如何显示。有如下值设置： start——省略号显示在开头; end——省略号显示在结尾; middle—-省略号显示在中间; marquee——以跑马灯的方式显示(动画横向移动)####android:textAppearance设置文字外观 如 “?android:attr/textAppearanceLargeInverse”这里引用的是系统自带的一个外观，?表示系统是否有这种外观，否则使用默认的外观。可设置的值如下：textAppearanceButtontextAppearanceInversetextAppearanceLargetextAppearanceLargeInversetextAppearanceMediumtextAppearanceMediumInversetextAppearanceSmalltextAppearanceSmallInverse ####android:drawableLeft在text的左边输出一个drawable 如果指定一个颜色的话会把text的背景设为该颜色，并且同时和background使用时覆盖后者。 android:drawableLeft在text的左边输出一个drawable android:drawableRight在text的右边输出一个drawable android:drawableTop在text的正上方输出一个drawable android:drawableBottom在text的下方输出一个drawable ####android:drawablePadding设置text与drawable(图片)的间隔 android:drawablePadding设置text与drawable(图片)的间隔，与drawableLeft、drawableRight、drawableTop、drawableBottom一起使用，可设置为负数，单独使用没有效果。 ###TextView多行/字符个数设置宽度android:ems设置TextView的宽度为N个字符的宽度。一个汉字字符宽度。android:maxEms设置TextView的宽度为最长为N个字符的宽度。与ems同时使用时覆盖ems选项。android:minEms设置TextView的宽度为最短为N个字符的宽度。与ems同时使用时覆盖ems选项。android:maxLength限制显示的文本长度，超出部分不显示。android:lines设置文本的行数，设置两行就显示两行，即使第二行没有数据。android:maxLines设置文本的最大显示行数，与width或layout_width结合使用，超出部分自动换行，超出行数将不显示。android:minLines设置文本的最小行数，与lines类似。android:lineSpacingExtra设置行间距。android:lineSpacingMultiplier设置行间距的倍数。如”1.2” ###文本阴影android:shadowColor指定文本阴影的颜色，需要shadowRadius一起使用。android:shadowRadius设置阴影的半径。设置为0.1就变成字体的颜色了，一般设置为3.0的效果比较好。android:shadowDx设置阴影横向坐标开始位置。android:shadowDy设置阴影纵向坐标开始位置。 ###坑 ####多余空白 android:includeFontPadding设置文本是否包含顶部和底部额外空白，默认为true。 ####设置指定输入法android:inputMethod为文本指定输入法，需要完全限定名(完整的包名)。例如：com.google.android.inputmethod.pinyin，但是这里报错找不到。 ##EditTextEditText继承TextView，所以EditText具有TextView的属性特点 ###常用 android:singleLine：设置单行输入，一旦设置为true，则文字不会自动换行。 android:gray=”top”：多行中指针在第一行第一位置 et.setSelection(et.length());：调整光标到最后一行 android:hint：EditText为空时显示的文字提示信息 android:textColorHint设置提示信息的颜色。 android:capitalize ：设置英文字母大写类型。设置如下值： sentences仅第一个字母大写 words每一个单词首字母大小，用空格区分单词 characters每一个英文字母都大写。 android:editable ：设置是否可编辑。仍然可以获取光标，但是无法输入。 android:textColorHighlight=”#cccccc”：被选中文字的底色，默认为蓝色 android:textColorHint=”#ffff00”：设置提示信息文字的颜色，默认为灰色 android:textScaleX=”1.5”：控制字与字之间的间距 android:typeface=”monospace”：字型 normal sans serif monospace android:background=”@null”：空间背景，这里没有，指透明 ####android:inputType:设置文本的类型 android:inputType=”none”输入普通字符android:inputType=”text”–输入普通字符android:inputType=”textCapCharacters”–输入普通字符android:inputType=”textCapWords”–单词首字母大小android:inputType=”textCapSentences”–仅第一个字母大小android:inputType=”textAutoCorrect”–前两个自动完成android:inputType=”textAutoComplete”–前两个自动完成android:inputType=”textMultiLine”–多行输入android:inputType=”textImeMultiLine”–输入法多行（不一定支持）android:inputType=”textNoSuggestions”–不提示android:inputType=”textUri”–URI格式android:inputType=”textEmailAddress”–电子邮件地址格式android:inputType=”textEmailSubject”–邮件主题格式android:inputType=”textShortMessage”–短消息格式android:inputType=”textLongMessage”–长消息格式android:inputType=”textPersonName”–人名格式android:inputType=”textPostalAddress”–邮政格式android:inputType=”textPassword”–密码格式android:inputType=”textVisiblePassword”–密码可见格式android:inputType=”textWebEditText”–作为网页表单的文本格式android:inputType=”textFilter”–文本筛选格式android:inputType=”textPhonetic”–拼音输入格式android:inputType=”number”–数字格式android:inputType=”numberSigned”–有符号数字格式android:inputType=”numberDecimal”–可以带小数点的浮点格式android:inputType=”datetime”android:inputType=”date”–日期键盘 android:inputType=”time”–时间键盘 ###不常用 ####android:selectAllOnFocus如果文本是可选择的，让他获取焦点而不是将光标移动为文本的开始位置或者末尾位置。 TextView中设置后无效果。 ###几乎不用 1.android:autoText ：自动拼写帮助。这里单独设置是没有效果的，可能需要其他输入法辅助才行 ###坑","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/wwjlife/tags/Android/"},{"name":"TextView","slug":"TextView","permalink":"https://github.com/wwjlife/tags/TextView/"},{"name":"EditText","slug":"EditText","permalink":"https://github.com/wwjlife/tags/EditText/"}]},{"title":"Android Studio添加依赖库","date":"2016-02-24T10:04:21.000Z","path":":/title/","text":"在Android Studio有不同的依赖添加： 添加自己下载的依赖 1.添加下载的jar包：这个我想大家都都知道，直接放在//build/libs下点击modulesetting，点击module找到dependencies，然后点击添加File dependency。 添加一些依赖的开源项目 首先在project创建一个跟你module同级目录library（名字随你）-&gt; 把你下载的开源项目（library为例）放进这个文件夹-&gt; 编辑settings.gradle，添加：include ‘:myModule’, ‘:library’ -&gt; 编辑你的module下的build.gradle文件，如下： 1234567dependencies &#123; compile fileTree(dir: 'libs', include: ['*.jar']) testCompile 'junit:junit:4.12' compile 'com.android.support:appcompat-v7:22.2.1'//调用远程代码 compile 'com.android.support:recyclerview-v7:22.2.1' compile project(':library')//添加这行代码&#125;","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/wwjlife/tags/Android/"},{"name":"Android Studio添加依赖库","slug":"Android-Studio添加依赖库","permalink":"https://github.com/wwjlife/tags/Android-Studio添加依赖库/"}]},{"title":"utils","date":"2016-02-23T08:21:21.000Z","path":":/title/","text":"###LogLog最佳实践 消灭TAG 我们用TAG就是做定位，同时方便过滤无意义的log。那么索性把当前类名作为这样一个TAG的标识。于是，在我们自定义的log类中就用如下代码设置tag： 1234567891011/** * @return 当前的类名(simpleName) */ private static String getClassName() &#123; String result; StackTraceElement thisMethodStack = (new Exception()).getStackTrace()[1]; result = thisMethodStack.getClassName(); int lastIndex = result.lastIndexOf(\".\"); result = result.substring(lastIndex + 1, result.length()); return result; &#125; 将Log简化 在终端能显示当前类名并且增加超链 这个功能其实ide是支持的，只不过我们可以通过一些神奇的方法来做到更好的效果。下面就给出两个可行的方法： 12345678910111213141516171819202122/** * @return 当前的类名（全名） */ private static String getClassName() &#123; String result; StackTraceElement thisMethodStack = (new Exception()).getStackTrace()[1]; result = thisMethodStack.getClassName(); return result; &#125; /** * log这个方法就可以显示超链 */ private static String callMethodAndLine() &#123; String result = \"at \"; StackTraceElement thisMethodStack = (new Exception()).getStackTrace()[1]; result += thisMethodStack.getClassName()+ \".\"; result += thisMethodStack.getMethodName(); result += \"(\" + thisMethodStack.getFileName(); result += \":\" + thisMethodStack.getLineNumber() + \") \"; return result; &#125; 让log更加美观 让log支持输出object、map、list、array、jsonStr等对象 增加log自动化和强制开关 ####疑点 123(new Exception()).getStackTrace()[1];new Exception().getStackTrace()[1];(new Exception()).getStackTrace()[2]; 原文地址","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/wwjlife/tags/Android/"},{"name":"Utils","slug":"Utils","permalink":"https://github.com/wwjlife/tags/Utils/"}]},{"title":"Android Scroll","date":"2016-01-12T07:31:21.000Z","path":":/title/","text":"###Android坐标系 在Android中，将屏幕最左上角的顶点作为Android的坐标系远点，往右和往下为正。 ###Android视图坐标系 视图坐标系，原点不在是Android坐标系中的屏幕最左上角，而是以父视图左上角为坐标原点。 ###触控事件——MotionEvent触控事件MotionEvent中封装了一些常用的事件常量，它定义了触控事件的不同类型。 1234567891011121314//单点触摸按下动作public static final int ACTION_DOWN = 0;//单点触摸离开动作public static final int ACTION_UP = 1;//触摸点移动动作public static final int ACTION_MOVE = 2;//触摸动作取消public static final int ACTION_CANCEL = 3;//触摸动作超出边界public static final int ACTION_OUTSIDE = 4;//多点触摸按下动作public static final int ACTION_POINTER_DOWN = 5;//多点触摸离开动作public static final int ACTION_POINTER_UP = 6; 通常情况下，我们会在onTouchEvent（MotionEvent event）方法中通过event.getAction()方法来获取触控事件的类型，并使用switch-case方法来进行筛选，这个代码的模式基本固定，如下： 123456789101112131415161718@Overridepublic boolean onTouchEvent(MotionEvent event)&#123; //获取当前输入点的X、Y坐标（）视图坐标 int x = (int)event.getX(); int y = (int)event.getY(); switch(event.getAction)&#123; case MotionEvent.ACTION_DOWN: //处理输入的按下事件 break; case MotionEvent.ACTION_MOVE: //处理输入的移动事件 break; case MotionEvent.ACTION_UP: //处理输入的离开事件 break; &#125; return true;&#125; ###获取坐标值的各种方法 View提供的获取坐标的方法。 getTop()：获取到的是View自身的顶边到其父布局顶边的距离。 getLeft()：获取到的是View自身的左边到其父布局左边的距离。 getRight()：获取到的是View自身的右边到其父布局左边的距离。 getBottom()：获取到的是View自身的底边到其父布局顶边的距离。 MotionEvent提供的方法。 getX()：获取点击事件距离控件左边的距离，即视图坐标。 getY()：获取点击事件距离控件顶边的距离，即视图坐标。 getRawX()：获取点击事件距离整个屏幕左边的距离，即绝对坐标。 getRawX()：获取点击事件距离整个屏幕顶边的距离，即绝对坐标。","tags":[{"name":"Android Scroll","slug":"Android-Scroll","permalink":"https://github.com/wwjlife/tags/Android-Scroll/"},{"name":"Android","slug":"Android","permalink":"https://github.com/wwjlife/tags/Android/"}]},{"title":"File操作","date":"2015-12-16T07:38:21.000Z","path":":/title/","text":"###获取总根 1234File[] fileList=File.listRoots(); //返回fileList.length为1 //fileList.getAbsolutePath()为\"/\" //这就是系统的总根 ###打开总根目录 12345File file=new File(\"/\"); File[] fileList=file.listFiles(); //获取的目录中除了\"/sdcard\"和\"/system\"还有\"/data\"、\"/cache\"、\"/dev\"等//Android的根目录并不像Symbian系统那样分为C盘、D盘、E盘等 //Android是基于Linux的，只有目录，无所谓盘符 ###获取系统存储根目录 1234File file=Environment.getRootDirectory();//File file=new File(\"/system\"); File[] fileList=file.listFiles(); //这里说的系统仅仅指\"/system\" //不包括外部存储的手机存储的范围远远大于所谓的系统存储 ###获取SD卡存储根目录 123456File file=Environment.getExternalStorageDirectory();//File file=new File(\"/sdcard\"); File[] fileList=file.listFiles(); //要获取SD卡首先要确认SD卡是否装载 boolean is=Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED); //如果true，则已装载 //如果false，则未装载 ###获取data根目录 123File file=Environment.getDataDirectory();//File file=new File(\"/data\"); File[] fileList=file.listFiles(); //由于data文件夹是android里一个非常重要的文件夹，所以一般权限是无法获取到文件的，即fileList.length返回为0 ###获取私有文件路径 1234567Context context=this;//首先，在Activity里获取context File file=context.getFilesDir(); String path=file.getAbsolutePath(); //此处返回的路劲为/data/data/包/files，其中的包就是我们建立的主Activity所在的包 //我们可以看到这个路径也是在data文件夹下 //程序本身是可以对自己的私有文件进行操作 //程序中很多私有的数据会写入到私有文件路径下，这也是android为什么对data数据做保护的原因之一 ###获取文件（夹）绝对路径、相对路劲、文件（夹）名、父目录 12345File file=…… String relativePath=file.getPath();//相对路径 String absolutePath=file.getAbsolutePath();//绝对路径 String fileName=file.getName();//文件（夹）名 String parentPath=file.getParent();//父目录 ###列出文件夹下的所有文件和文件夹 12File file=…… File[] fileList=file.listFiles(); ###判断是文件还是文件夹 12File file=…… boolean is=file.isDirectory();//true-是，false-否 ###判断文件（夹）是否存在 12File file=…… boolean is=file.exists();//true-是，false-否 ###新建文件（夹） 1234567891011121314151617181920212223File file=…… oolean is=file.isDirectory();//判断是否为文件夹 /*方法1*/ if(is)&#123; String path=file.getAbsolutePath(); String name=\"ABC\";//你要新建的文件夹名或者文件名 String pathx=path+name; File filex=new File(pathx); boolean is=filex.exists();//判断文件（夹）是否存在 if(!is)&#123; filex.mkdir();//创建文件夹 //filex.createNewFile();//创建文件 &#125; /*方法2*/ if(is)&#123; String path=file.getAbsolutePath(); String name=\"test.txt\";//你要新建的文件夹名或者文件名 File filex=new File(path,name);//方法1和方法2的区别在于此 boolean is=filex.exists();//判断文件（夹）是否存在 if(!is)&#123; filex.mkdir();//创建文件夹 //filex.createNewFile();//创建文件 &#125; ###重命名文件（夹） 12345File file=…… String parentPath=file.getParent(); String newName=\"name\";//重命名后的文件或者文件夹名 File filex=new File(parentPath,newName);//File filex=new File(parentPaht+newName) file.renameTo(filex); ###删除文件（夹） 123File file=…… file.delete();//立即删除 //file.deleteOnExit();//程序退出后删除，只有正常退出才会删除 原地址：Android入门之文件系统操作（二）文件操作相关指令 ###view plainprint? Android 2.3提供一个称为严苛模式（StrictMode）的调试特性 唯一一篇讲到在2.3之前要怎么处理的文章","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/wwjlife/tags/Android/"},{"name":"File","slug":"File","permalink":"https://github.com/wwjlife/tags/File/"}]},{"title":"File操作","date":"2015-12-16T07:38:21.000Z","path":":/title/","text":"###获取总根 1234File[] fileList=File.listRoots(); //返回fileList.length为1 //fileList.getAbsolutePath()为\"/\" //这就是系统的总根 ###打开总根目录 12345File file=new File(\"/\"); File[] fileList=file.listFiles(); //获取的目录中除了\"/sdcard\"和\"/system\"还有\"/data\"、\"/cache\"、\"/dev\"等//Android的根目录并不像Symbian系统那样分为C盘、D盘、E盘等 //Android是基于Linux的，只有目录，无所谓盘符 ###获取系统存储根目录 1234File file=Environment.getRootDirectory();//File file=new File(\"/system\"); File[] fileList=file.listFiles(); //这里说的系统仅仅指\"/system\" //不包括外部存储的手机存储的范围远远大于所谓的系统存储 ###获取SD卡存储根目录 123456File file=Environment.getExternalStorageDirectory();//File file=new File(\"/sdcard\"); File[] fileList=file.listFiles(); //要获取SD卡首先要确认SD卡是否装载 boolean is=Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED); //如果true，则已装载 //如果false，则未装载 ###获取data根目录 123File file=Environment.getDataDirectory();//File file=new File(\"/data\"); File[] fileList=file.listFiles(); //由于data文件夹是android里一个非常重要的文件夹，所以一般权限是无法获取到文件的，即fileList.length返回为0 ###获取私有文件路径 1234567Context context=this;//首先，在Activity里获取context File file=context.getFilesDir(); String path=file.getAbsolutePath(); //此处返回的路劲为/data/data/包/files，其中的包就是我们建立的主Activity所在的包 //我们可以看到这个路径也是在data文件夹下 //程序本身是可以对自己的私有文件进行操作 //程序中很多私有的数据会写入到私有文件路径下，这也是android为什么对data数据做保护的原因之一 ###获取文件（夹）绝对路径、相对路劲、文件（夹）名、父目录 12345File file=…… String relativePath=file.getPath();//相对路径 String absolutePath=file.getAbsolutePath();//绝对路径 String fileName=file.getName();//文件（夹）名 String parentPath=file.getParent();//父目录 ###列出文件夹下的所有文件和文件夹 12File file=…… File[] fileList=file.listFiles(); ###判断是文件还是文件夹 12File file=…… boolean is=file.isDirectory();//true-是，false-否 ###判断文件（夹）是否存在 12File file=…… boolean is=file.exists();//true-是，false-否 ###新建文件（夹） 1234567891011121314151617181920212223File file=…… oolean is=file.isDirectory();//判断是否为文件夹 /*方法1*/ if(is)&#123; String path=file.getAbsolutePath(); String name=\"ABC\";//你要新建的文件夹名或者文件名 String pathx=path+name; File filex=new File(pathx); boolean is=filex.exists();//判断文件（夹）是否存在 if(!is)&#123; filex.mkdir();//创建文件夹 //filex.createNewFile();//创建文件 &#125; /*方法2*/ if(is)&#123; String path=file.getAbsolutePath(); String name=\"test.txt\";//你要新建的文件夹名或者文件名 File filex=new File(path,name);//方法1和方法2的区别在于此 boolean is=filex.exists();//判断文件（夹）是否存在 if(!is)&#123; filex.mkdir();//创建文件夹 //filex.createNewFile();//创建文件 &#125; ###重命名文件（夹） 12345File file=…… String parentPath=file.getParent(); String newName=\"name\";//重命名后的文件或者文件夹名 File filex=new File(parentPath,newName);//File filex=new File(parentPaht+newName) file.renameTo(filex); ###删除文件（夹） 123File file=…… file.delete();//立即删除 //file.deleteOnExit();//程序退出后删除，只有正常退出才会删除 原地址：Android入门之文件系统操作（二）文件操作相关指令 ###view plainprint? Android 2.3提供一个称为严苛模式（StrictMode）的调试特性 唯一一篇讲到在2.3之前要怎么处理的文章","tags":[{"name":"随笔","slug":"随笔","permalink":"https://github.com/wwjlife/tags/随笔/"},{"name":"游记","slug":"游记","permalink":"https://github.com/wwjlife/tags/游记/"},{"name":"吃货","slug":"吃货","permalink":"https://github.com/wwjlife/tags/吃货/"},{"name":"教程","slug":"教程","permalink":"https://github.com/wwjlife/tags/教程/"},{"name":"Android","slug":"Android","permalink":"https://github.com/wwjlife/tags/Android/"},{"name":"File","slug":"File","permalink":"https://github.com/wwjlife/tags/File/"}]}]
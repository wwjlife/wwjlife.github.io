[{"title":"最初的你还在么？","date":"2016-05-27T13:21:21.000Z","path":"随笔/最初的你还在么/","text":"没有人能一路单纯到底，但要记住，别忘了最初的自己。 心情不好时，闭上眼，告诉自己，这是幻觉。 我有一个的愿望，就像别人说的那样：没心没肺，人活百岁，问心无愧，做人不累。本以为，按照自己所想的方式，这些就会变得容易起来。能够放下浮躁的心，撇开一切的影响，坚持把一件事做下去，不忘初心，多好。所有的所有，慢慢的开始变得艰难起来。人的一生，你将无法预计可以遇见多少人，与怎么样的人相处，有多少事与他们关联着。哪些是你喜欢的，哪些是你讨厌的，甚至厌恶的。一切无法知晓。某天，你终要一个人去面对的。 ♢♢♢ 最近的一段时间，我深深地陷入苦恼中。我觉得自己要疯了，特别讨厌自己暴躁地发脾气。小D，其貌不扬，工作还算认真，是我公司的一个同事。刚开始相处时，还是挺好的，共事也愉快。时间久了，小D慢慢地暴露一些恶习。我开始发现，他这个人很喜欢吃别的同事零食。只要是同事办公桌上可以看得到的可以吃的东西，他随手一抓就往自个嘴巴里放，完全不经人家同意，就当自家似的。我是个比较爱带点零食回办公室的人，比如饼干、糖、水果等，因为我在公司午饭有时候吃不饱，下午一饿就可以拿这些来充饥。当然我是个爱分享的人，有吃的总会分给同事们的。有好几次我发现带来的零食，自己还没吃，就不见了，就剩下个袋子，觉得奇怪。有一天我发现，原来是他全偷吃了。如果他堂堂正正来问我要，我完全可以给他吃的，我还会觉得他是一个有礼貌的人。可为什么非要做出如此龌龊行为？我很难理解。小D一直说自己不买零食，坚决说自己并不喜欢吃零食。他自己却常常吃别人的零食吃最多，都不想想别人自己买的还没吃，全被他吃光了。你跟他说道理，完全不管用。就连饭菜，也会用舌舔过的筷子顺手夹别人的吃。他还会反驳你，说大家都很熟了，不介意的。得了便宜，还不买乖。我开始苦笑。后来我已经怕他了，越发少往公司带吃的了。 ♢♢♢ 我是个保守的人，不喜欢和别人过度开露骨的玩笑，更是厌恶一个男性没资本还轻佻浮夸毫无距离磨蹭女性。我相信每个人心底都有自己不可触碰的底线，就像一条导火线，点着了，一定会炸起来的。小D很爱说话，整个办公室就他话唠，众愤。我并不喜欢和他说话，总生怕一不小心就被他拉下素质的水平来。这是很恐怖的事。小D在办公室一唠叨，我觉得他就像一个苍蝇，还经常在我头顶嗡嗡飞的那种，闹心的烦，总想逮个机会一巴掌拍死。除了工作上的事，很多时候，我总会无视他，甭搭理他。前两周，他刚和一个谈了两个月左右的女孩分手。他谈过几个女孩，好似都没成。他谈女孩都是很装，装有钱，装好男人，最初并非诚心。久了，本性暴露了，多是女性提出分手。每次失败他都在埋怨女孩那方不懂事，在背后狂骂的哪种，还专到我耳根嘀咕，这一刻我总想把他踩到鞋底下。多恋败仗，自身问题。成与不成，人品问题。长不长久，诚心问题。可他说着说着，激动了，说到我头上来了。我一头雾水。莫名奇妙的开玩笑，我故意给他台阶下，而他还不知趣，趁势而上。而且老戳我，再加上某些言语彻底把我底线击垮，就这样我们在办公司肆无忌惮地吵了起来。“不顾及别人感受是自私，太顾及别人感受是自虐”。很多时候我是后者，今时我更愿意是前者。 ♢♢♢ 小D还是个不注重卫生的人。他在办公室的座位地板都是污迹斑斑的，桌面凌乱不雅，就连经常用的东西都粘灰。我是个爱干净的人，觉得他很脏，多次友善提醒他注意维护公共场所卫生清洁，屡次不听。每次经理看到脏，总批评说我工作失职，没管理好办公室环境卫生。我一肚子憋屈，不知道多少次叫他本人把自己桌子收拾干净、整齐，从来不听，也不去做。他这个人时不时轻浮挑逗你，嬉皮笑脸忽悠人，一脸的不尊重人。我看不惯，肚子就会积火。我的脾气变得越来越暴躁。我的声音变得越来越大声。久而久之，忍不住了就会吵起来。德国作家席勒曾说：“不尊重别人的人，别人也不会尊重他”。当初的种种好，我现在都是不以为然的。一个不尊重你的人，对他所做的事或许都是徒劳无意义的。 ♢♢♢ 在社会上工作越久，你会发现职场里的人就像河水，有深，有浅，有净，有脏，你要懂得从容。还要熟悉一些职场潜规则，逼自己学会保护自己。今年1月份，我去上海总部开总结大会，开会内容主要是针对2015年所有财务数据、费用以及销售业绩的总结，制定来年工作的计划。我清楚的记得自己在大会上发言，当时特紧张，准备了一个多月的言稿，即使练了好多次，依然不够淡定。我却装着应付裕如的样子，呈现完整的发言内容，完毕后松了一口气。这个时候的感觉就像会领奖一样，台下响起雷鸣般的掌声，总经理还不停的夸奖。看到这一切，似乎都很美好，内心仿佛在翩翩起舞。事后，我怎么也没想到，我会被经理找去训话。我无法理解当所有的人都在赞扬你的时候而经理否定你的这一行为。我希望在公司好好的工作，发现了问题，就该说出事实，提出建议方案，大家共同把问题解决，提高工作效率，让公司发展更好。而且党的思想基本路线都在提倡：一切从实际出发,理论联系实际,实事求是,在实践中检验真理和发展真理。我只不过是说出了事实，经理说我字眼针对某些同事，态度激烈。我有口难辩。我完全没有针对任何同事，心里感到很委屈。我开始怀疑公司领导、同事对我的称赞，这个地方飘着一层雾，看不清。社会真的可以历练一个人，吃过亏，受过委屈，就会学到一些东西，人也就成长了。很热播的一部剧《欢乐颂》，有一集是说小邱和白主管在公司翻脸的事，剧中人物设计的渣男白主管因为感情失败产生一种刁难捉弄可爱的小邱的发狠心态，好几次都不给小邱报销她部门经理出差的费用。最终逼得傻萌的小邱当着领导、同事的面暴出了白主管一直以来的财务数据不真实，假公济私暗中捞取便宜的而工作不负责任的一面。后来白主管被开除，我大快人心，觉得小邱有勇气说出事实，做得很好，公司就该表扬。可谁也没想到剧情中的小邱被公司辞退了。你会蓦然地发现，职场作为人生的演绎，有很多你需要去悟透的潜规则，用技巧性地去战斗、去奋斗、去成功。长大后才发现，有时候你说了真话，你还得和人家道歉，因为你戳穿了事实。所以想要活得顺畅，请时刻带上脑子。 ♢♢♢ 我现在觉得微信是个好玩意。每次职场遇到不顺、恼火、忍受不了的事情，我就会在微信里找朋友吐槽。只有诉说出来之后，心里才是舒服的。很多朋友说，出来社会工作久了都会发现一个共同的问题，就是会感觉到当初自己一味对别人好，受伤的很多时候是自己。很多发生在电视剧剧情中所安排的事，原来没有人安排，这些还是会发生在我们身边的。闺蜜也认真的对我说：“人真的会变，我也不是当初的自己了。社会真的会改变一个人”。我不想去表态这些残忍的现实。在这里我想借用季羡林的话：好多年来，我曾有过一个“良好”的愿望，我对每个人都好，也希望每个人都对我好。只望有誉，不能毁。最近我恍然大悟，那是根本不可能的。有时候，善良要有底线，大方要有原则。不分青红皂白只知道对人好，那么会辜负自己的一片好心。最后，我想用德高望重的杨绛先生的话来来收尾：“在这物欲横流的人世间，人生一世实在是够苦。你存心做一个与世无争的老实人吧，人家就利用你欺悔你。你稍有才德品貌，人家就嫉妒你排挤你。你大度退让，人家就侵犯你损害你。你要不与人争，就得与世无求，同时还要维持实力准备斗争。你要和别人和平共处，就先得和他们周旋，还得准备随时吃亏”。保留当初的善良与纯真，坚守着自己的原则。这是多么难能可贵的东西！","tags":[{"name":"随笔","slug":"随笔","permalink":"https://github.com/wwjlife/tags/随笔/"},{"name":"初心，小故事","slug":"初心，小故事","permalink":"https://github.com/wwjlife/tags/初心，小故事/"}]},{"title":"String","date":"2016-02-24T13:21:21.000Z","path":"Android/String/","text":"###String String一旦被赋值，便不能更改其指向的字符对象，如果更改，则会指向一个新的字符对象。 当String的变量作为参数传递到函数中，即使函数中改变了它的值，但对函数外是没有影响。（这个是String的特例，其他引用类型一般都会产生影响的） ###StringBuffer ####StringBuffer的构造函数 StringBuffer() StringBuffer(int size) StringBuffer(String str) StringBuffer(CharSequence chars) ####length()和capacity()length()计算StringBuffer当前长度,而整个可分配空间通过capacity()方法得到。 ####ensureCapacity() 设置缓冲区的大小void ensureCapacity(int capacity) ####setLength() 设置缓冲区的长度void setLength(int len) charAt()和setCharAt()char charAt(int where)void setCharAt(int where,char ch) ####getChars()void getChars(int sourceStart,int sourceEnd,char target[],int targetStart) ####append() 可把任何类型数据的字符串表示连接到调用它的StringBuffer对象的末尾。例：int a=42;StringBuffer sb=new StringBuffer(40);String s=sb.append(”a=”).append(a).append(”!”).toString(); ####insert() 插入字符串StringBuffer insert(int index,String str)StringBuffer insert(int index,char ch)StringBuffer insert(int index,Object obj)index指定将字符串插入到StringBuffer对象中的位置的下标。 ####reverse() 颠倒StringBuffer对象中的字符StringBuffer reverse() ####delete()和deleteCharAt() 删除字符StringBuffer delete(int startIndex,int endIndex)StringBuffer deleteCharAt(int loc) ####replace() 替换StringBuffer replace(int startIndex,int endIndex,String str) ####substring() 截取子串String substring(int startIndex)String substring(int startIndex,int endIndex) ###字符串转数字的函数【原文出处】 ####转换字符串为数字12345678/** 转换字符串为数字 */public static int strToInt(String value, int defaultValue) &#123; try &#123; return Integer.valueOf(value); &#125; catch (Exception e) &#123; return defaultValue; &#125; &#125; ####转换字符串为数字 12345678/** 转换字符串为数字 */public static long strToInt(String value, long defaultValue) &#123; try &#123; return Long.valueOf(value); &#125; catch (Exception e) &#123; return defaultValue; &#125; &#125; ####转换16进制字符串为数字12345678/** 转换16进制字符串为数字 */public static int hexToInt(String value, int defaultValue) &#123; try &#123; return Integer.parseInt(value, 16); &#125; catch (Exception e) &#123; return defaultValue; &#125; &#125; ####转换16进制字符串为数字12345678/** 转换16进制字符串为数字 */public static long hexToInt(String value, long defaultValue) &#123; try &#123; return Long.parseLong(value, 16); &#125; catch (Exception e) &#123; return defaultValue; &#125; &#125; ####转换字符串为数字12345678/** 转换字符串为数字 */public static float strToFloat(String value, float defaultValue) &#123; try &#123; return Float.valueOf(value); &#125; catch (Exception e) &#123; return defaultValue; &#125; &#125; ####转换字符串为数字12345678/** 转换字符串为数字 */public static double strToDouble(String value, double defaultValue) &#123; try &#123; return Double.valueOf(value); &#125; catch (Exception e) &#123; return defaultValue; &#125; &#125;","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/wwjlife/tags/Android/"},{"name":"String","slug":"String","permalink":"https://github.com/wwjlife/tags/String/"}]},{"title":"TextView／EditText","date":"2016-02-24T13:21:21.000Z","path":"Android/TextView／EditText/","text":"##TextView ###常用 android:singleLine设置单行显示 android:textColor设置文本颜色 android:textColorLink文字链接的颜色. android:textScaleX设置文字之间间隔，默认为1.0f android:textColorHighlight被选中文字的底色，默认为蓝色 android:scrollHorizontally设置文本超出TextView的宽度的情况下，是否出现横拉条。 android:hintText为空时显示的文字提示信息 android:textColorHint设置提示信息文字的颜色，默认为灰色。与hint一起使用。 ###不常用 ####android:cursorVisible设定光标为显示/隐藏，默认显示。 ####android:ellipsize设置当文字过长时,该控件该如何显示。有如下值设置： start——省略号显示在开头; end——省略号显示在结尾; middle—-省略号显示在中间; marquee——以跑马灯的方式显示(动画横向移动)####android:textAppearance设置文字外观 如 “?android:attr/textAppearanceLargeInverse”这里引用的是系统自带的一个外观，?表示系统是否有这种外观，否则使用默认的外观。可设置的值如下：textAppearanceButtontextAppearanceInversetextAppearanceLargetextAppearanceLargeInversetextAppearanceMediumtextAppearanceMediumInversetextAppearanceSmalltextAppearanceSmallInverse ####android:drawableLeft在text的左边输出一个drawable 如果指定一个颜色的话会把text的背景设为该颜色，并且同时和background使用时覆盖后者。 android:drawableLeft在text的左边输出一个drawable android:drawableRight在text的右边输出一个drawable android:drawableTop在text的正上方输出一个drawable android:drawableBottom在text的下方输出一个drawable ####android:drawablePadding设置text与drawable(图片)的间隔 android:drawablePadding设置text与drawable(图片)的间隔，与drawableLeft、drawableRight、drawableTop、drawableBottom一起使用，可设置为负数，单独使用没有效果。 ###TextView多行/字符个数设置宽度android:ems设置TextView的宽度为N个字符的宽度。一个汉字字符宽度。android:maxEms设置TextView的宽度为最长为N个字符的宽度。与ems同时使用时覆盖ems选项。android:minEms设置TextView的宽度为最短为N个字符的宽度。与ems同时使用时覆盖ems选项。android:maxLength限制显示的文本长度，超出部分不显示。android:lines设置文本的行数，设置两行就显示两行，即使第二行没有数据。android:maxLines设置文本的最大显示行数，与width或layout_width结合使用，超出部分自动换行，超出行数将不显示。android:minLines设置文本的最小行数，与lines类似。android:lineSpacingExtra设置行间距。android:lineSpacingMultiplier设置行间距的倍数。如”1.2” ###文本阴影android:shadowColor指定文本阴影的颜色，需要shadowRadius一起使用。android:shadowRadius设置阴影的半径。设置为0.1就变成字体的颜色了，一般设置为3.0的效果比较好。android:shadowDx设置阴影横向坐标开始位置。android:shadowDy设置阴影纵向坐标开始位置。 ###坑 ####多余空白 android:includeFontPadding设置文本是否包含顶部和底部额外空白，默认为true。 ####设置指定输入法android:inputMethod为文本指定输入法，需要完全限定名(完整的包名)。例如：com.google.android.inputmethod.pinyin，但是这里报错找不到。 ##EditTextEditText继承TextView，所以EditText具有TextView的属性特点 ###常用 android:singleLine：设置单行输入，一旦设置为true，则文字不会自动换行。 android:gray=”top”：多行中指针在第一行第一位置 et.setSelection(et.length());：调整光标到最后一行 android:hint：EditText为空时显示的文字提示信息 android:textColorHint设置提示信息的颜色。 android:capitalize ：设置英文字母大写类型。设置如下值： sentences仅第一个字母大写 words每一个单词首字母大小，用空格区分单词 characters每一个英文字母都大写。 android:editable ：设置是否可编辑。仍然可以获取光标，但是无法输入。 android:textColorHighlight=”#cccccc”：被选中文字的底色，默认为蓝色 android:textColorHint=”#ffff00”：设置提示信息文字的颜色，默认为灰色 android:textScaleX=”1.5”：控制字与字之间的间距 android:typeface=”monospace”：字型 normal sans serif monospace android:background=”@null”：空间背景，这里没有，指透明 ####android:inputType:设置文本的类型 android:inputType=”none”输入普通字符android:inputType=”text”–输入普通字符android:inputType=”textCapCharacters”–输入普通字符android:inputType=”textCapWords”–单词首字母大小android:inputType=”textCapSentences”–仅第一个字母大小android:inputType=”textAutoCorrect”–前两个自动完成android:inputType=”textAutoComplete”–前两个自动完成android:inputType=”textMultiLine”–多行输入android:inputType=”textImeMultiLine”–输入法多行（不一定支持）android:inputType=”textNoSuggestions”–不提示android:inputType=”textUri”–URI格式android:inputType=”textEmailAddress”–电子邮件地址格式android:inputType=”textEmailSubject”–邮件主题格式android:inputType=”textShortMessage”–短消息格式android:inputType=”textLongMessage”–长消息格式android:inputType=”textPersonName”–人名格式android:inputType=”textPostalAddress”–邮政格式android:inputType=”textPassword”–密码格式android:inputType=”textVisiblePassword”–密码可见格式android:inputType=”textWebEditText”–作为网页表单的文本格式android:inputType=”textFilter”–文本筛选格式android:inputType=”textPhonetic”–拼音输入格式android:inputType=”number”–数字格式android:inputType=”numberSigned”–有符号数字格式android:inputType=”numberDecimal”–可以带小数点的浮点格式android:inputType=”datetime”android:inputType=”date”–日期键盘 android:inputType=”time”–时间键盘 ###不常用 ####android:selectAllOnFocus如果文本是可选择的，让他获取焦点而不是将光标移动为文本的开始位置或者末尾位置。 TextView中设置后无效果。 ###几乎不用 1.android:autoText ：自动拼写帮助。这里单独设置是没有效果的，可能需要其他输入法辅助才行 ###坑","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/wwjlife/tags/Android/"},{"name":"TextView","slug":"TextView","permalink":"https://github.com/wwjlife/tags/TextView/"},{"name":"EditText","slug":"EditText","permalink":"https://github.com/wwjlife/tags/EditText/"}]},{"title":"Android Studio添加依赖库","date":"2016-02-24T10:04:21.000Z","path":"Android/Android studio添加依赖库/","text":"在Android Studio有不同的依赖添加： 添加自己下载的依赖 1.添加下载的jar包：这个我想大家都都知道，直接放在//build/libs下点击modulesetting，点击module找到dependencies，然后点击添加File dependency。 添加一些依赖的开源项目 首先在project创建一个跟你module同级目录library（名字随你）-&gt; 把你下载的开源项目（library为例）放进这个文件夹-&gt; 编辑settings.gradle，添加：include ‘:myModule’, ‘:library’ -&gt; 编辑你的module下的build.gradle文件，如下： 1234567dependencies &#123; compile fileTree(dir: 'libs', include: ['*.jar']) testCompile 'junit:junit:4.12' compile 'com.android.support:appcompat-v7:22.2.1'//调用远程代码 compile 'com.android.support:recyclerview-v7:22.2.1' compile project(':library')//添加这行代码&#125;","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/wwjlife/tags/Android/"},{"name":"Android Studio添加依赖库","slug":"Android-Studio添加依赖库","permalink":"https://github.com/wwjlife/tags/Android-Studio添加依赖库/"}]},{"title":"utils","date":"2016-02-23T08:21:21.000Z","path":"Android/Utils/","text":"###LogLog最佳实践 消灭TAG 我们用TAG就是做定位，同时方便过滤无意义的log。那么索性把当前类名作为这样一个TAG的标识。于是，在我们自定义的log类中就用如下代码设置tag： 1234567891011/** * @return 当前的类名(simpleName) */ private static String getClassName() &#123; String result; StackTraceElement thisMethodStack = (new Exception()).getStackTrace()[1]; result = thisMethodStack.getClassName(); int lastIndex = result.lastIndexOf(\".\"); result = result.substring(lastIndex + 1, result.length()); return result; &#125; 将Log简化 在终端能显示当前类名并且增加超链 这个功能其实ide是支持的，只不过我们可以通过一些神奇的方法来做到更好的效果。下面就给出两个可行的方法： 12345678910111213141516171819202122/** * @return 当前的类名（全名） */ private static String getClassName() &#123; String result; StackTraceElement thisMethodStack = (new Exception()).getStackTrace()[1]; result = thisMethodStack.getClassName(); return result; &#125; /** * log这个方法就可以显示超链 */ private static String callMethodAndLine() &#123; String result = \"at \"; StackTraceElement thisMethodStack = (new Exception()).getStackTrace()[1]; result += thisMethodStack.getClassName()+ \".\"; result += thisMethodStack.getMethodName(); result += \"(\" + thisMethodStack.getFileName(); result += \":\" + thisMethodStack.getLineNumber() + \") \"; return result; &#125; 让log更加美观 让log支持输出object、map、list、array、jsonStr等对象 增加log自动化和强制开关 ####疑点 123(new Exception()).getStackTrace()[1];new Exception().getStackTrace()[1];(new Exception()).getStackTrace()[2]; 原文地址","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/wwjlife/tags/Android/"},{"name":"Utils","slug":"Utils","permalink":"https://github.com/wwjlife/tags/Utils/"}]},{"title":"Android Scroll","date":"2016-01-12T07:31:21.000Z","path":"Android/AndroidScroll/","text":"###Android坐标系 在Android中，将屏幕最左上角的顶点作为Android的坐标系远点，往右和往下为正。 ###Android视图坐标系 视图坐标系，原点不在是Android坐标系中的屏幕最左上角，而是以父视图左上角为坐标原点。 ###触控事件——MotionEvent触控事件MotionEvent中封装了一些常用的事件常量，它定义了触控事件的不同类型。 1234567891011121314//单点触摸按下动作public static final int ACTION_DOWN = 0;//单点触摸离开动作public static final int ACTION_UP = 1;//触摸点移动动作public static final int ACTION_MOVE = 2;//触摸动作取消public static final int ACTION_CANCEL = 3;//触摸动作超出边界public static final int ACTION_OUTSIDE = 4;//多点触摸按下动作public static final int ACTION_POINTER_DOWN = 5;//多点触摸离开动作public static final int ACTION_POINTER_UP = 6; 通常情况下，我们会在onTouchEvent（MotionEvent event）方法中通过event.getAction()方法来获取触控事件的类型，并使用switch-case方法来进行筛选，这个代码的模式基本固定，如下： 123456789101112131415161718@Overridepublic boolean onTouchEvent(MotionEvent event)&#123; //获取当前输入点的X、Y坐标（）视图坐标 int x = (int)event.getX(); int y = (int)event.getY(); switch(event.getAction)&#123; case MotionEvent.ACTION_DOWN: //处理输入的按下事件 break; case MotionEvent.ACTION_MOVE: //处理输入的移动事件 break; case MotionEvent.ACTION_UP: //处理输入的离开事件 break; &#125; return true;&#125; ###获取坐标值的各种方法 View提供的获取坐标的方法。 getTop()：获取到的是View自身的顶边到其父布局顶边的距离。 getLeft()：获取到的是View自身的左边到其父布局左边的距离。 getRight()：获取到的是View自身的右边到其父布局左边的距离。 getBottom()：获取到的是View自身的底边到其父布局顶边的距离。 MotionEvent提供的方法。 getX()：获取点击事件距离控件左边的距离，即视图坐标。 getY()：获取点击事件距离控件顶边的距离，即视图坐标。 getRawX()：获取点击事件距离整个屏幕左边的距离，即绝对坐标。 getRawX()：获取点击事件距离整个屏幕顶边的距离，即绝对坐标。","tags":[{"name":"Android Scroll","slug":"Android-Scroll","permalink":"https://github.com/wwjlife/tags/Android-Scroll/"},{"name":"Android","slug":"Android","permalink":"https://github.com/wwjlife/tags/Android/"}]},{"title":"File操作","date":"2015-12-16T07:38:21.000Z","path":"Android/File操作/","text":"###获取总根 1234File[] fileList=File.listRoots(); //返回fileList.length为1 //fileList.getAbsolutePath()为\"/\" //这就是系统的总根 ###打开总根目录 12345File file=new File(\"/\"); File[] fileList=file.listFiles(); //获取的目录中除了\"/sdcard\"和\"/system\"还有\"/data\"、\"/cache\"、\"/dev\"等//Android的根目录并不像Symbian系统那样分为C盘、D盘、E盘等 //Android是基于Linux的，只有目录，无所谓盘符 ###获取系统存储根目录 1234File file=Environment.getRootDirectory();//File file=new File(\"/system\"); File[] fileList=file.listFiles(); //这里说的系统仅仅指\"/system\" //不包括外部存储的手机存储的范围远远大于所谓的系统存储 ###获取SD卡存储根目录 123456File file=Environment.getExternalStorageDirectory();//File file=new File(\"/sdcard\"); File[] fileList=file.listFiles(); //要获取SD卡首先要确认SD卡是否装载 boolean is=Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED); //如果true，则已装载 //如果false，则未装载 ###获取data根目录 123File file=Environment.getDataDirectory();//File file=new File(\"/data\"); File[] fileList=file.listFiles(); //由于data文件夹是android里一个非常重要的文件夹，所以一般权限是无法获取到文件的，即fileList.length返回为0 ###获取私有文件路径 1234567Context context=this;//首先，在Activity里获取context File file=context.getFilesDir(); String path=file.getAbsolutePath(); //此处返回的路劲为/data/data/包/files，其中的包就是我们建立的主Activity所在的包 //我们可以看到这个路径也是在data文件夹下 //程序本身是可以对自己的私有文件进行操作 //程序中很多私有的数据会写入到私有文件路径下，这也是android为什么对data数据做保护的原因之一 ###获取文件（夹）绝对路径、相对路劲、文件（夹）名、父目录 12345File file=…… String relativePath=file.getPath();//相对路径 String absolutePath=file.getAbsolutePath();//绝对路径 String fileName=file.getName();//文件（夹）名 String parentPath=file.getParent();//父目录 ###列出文件夹下的所有文件和文件夹 12File file=…… File[] fileList=file.listFiles(); ###判断是文件还是文件夹 12File file=…… boolean is=file.isDirectory();//true-是，false-否 ###判断文件（夹）是否存在 12File file=…… boolean is=file.exists();//true-是，false-否 ###新建文件（夹） 1234567891011121314151617181920212223File file=…… oolean is=file.isDirectory();//判断是否为文件夹 /*方法1*/ if(is)&#123; String path=file.getAbsolutePath(); String name=\"ABC\";//你要新建的文件夹名或者文件名 String pathx=path+name; File filex=new File(pathx); boolean is=filex.exists();//判断文件（夹）是否存在 if(!is)&#123; filex.mkdir();//创建文件夹 //filex.createNewFile();//创建文件 &#125; /*方法2*/ if(is)&#123; String path=file.getAbsolutePath(); String name=\"test.txt\";//你要新建的文件夹名或者文件名 File filex=new File(path,name);//方法1和方法2的区别在于此 boolean is=filex.exists();//判断文件（夹）是否存在 if(!is)&#123; filex.mkdir();//创建文件夹 //filex.createNewFile();//创建文件 &#125; ###重命名文件（夹） 12345File file=…… String parentPath=file.getParent(); String newName=\"name\";//重命名后的文件或者文件夹名 File filex=new File(parentPath,newName);//File filex=new File(parentPaht+newName) file.renameTo(filex); ###删除文件（夹） 123File file=…… file.delete();//立即删除 //file.deleteOnExit();//程序退出后删除，只有正常退出才会删除 原地址：Android入门之文件系统操作（二）文件操作相关指令 ###view plainprint? Android 2.3提供一个称为严苛模式（StrictMode）的调试特性 唯一一篇讲到在2.3之前要怎么处理的文章","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/wwjlife/tags/Android/"},{"name":"File","slug":"File","permalink":"https://github.com/wwjlife/tags/File/"}]},{"title":"File操作","date":"2015-12-16T07:38:21.000Z","path":"小故事/File操作/","text":"###获取总根 1234File[] fileList=File.listRoots(); //返回fileList.length为1 //fileList.getAbsolutePath()为\"/\" //这就是系统的总根 ###打开总根目录 12345File file=new File(\"/\"); File[] fileList=file.listFiles(); //获取的目录中除了\"/sdcard\"和\"/system\"还有\"/data\"、\"/cache\"、\"/dev\"等//Android的根目录并不像Symbian系统那样分为C盘、D盘、E盘等 //Android是基于Linux的，只有目录，无所谓盘符 ###获取系统存储根目录 1234File file=Environment.getRootDirectory();//File file=new File(\"/system\"); File[] fileList=file.listFiles(); //这里说的系统仅仅指\"/system\" //不包括外部存储的手机存储的范围远远大于所谓的系统存储 ###获取SD卡存储根目录 123456File file=Environment.getExternalStorageDirectory();//File file=new File(\"/sdcard\"); File[] fileList=file.listFiles(); //要获取SD卡首先要确认SD卡是否装载 boolean is=Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED); //如果true，则已装载 //如果false，则未装载 ###获取data根目录 123File file=Environment.getDataDirectory();//File file=new File(\"/data\"); File[] fileList=file.listFiles(); //由于data文件夹是android里一个非常重要的文件夹，所以一般权限是无法获取到文件的，即fileList.length返回为0 ###获取私有文件路径 1234567Context context=this;//首先，在Activity里获取context File file=context.getFilesDir(); String path=file.getAbsolutePath(); //此处返回的路劲为/data/data/包/files，其中的包就是我们建立的主Activity所在的包 //我们可以看到这个路径也是在data文件夹下 //程序本身是可以对自己的私有文件进行操作 //程序中很多私有的数据会写入到私有文件路径下，这也是android为什么对data数据做保护的原因之一 ###获取文件（夹）绝对路径、相对路劲、文件（夹）名、父目录 12345File file=…… String relativePath=file.getPath();//相对路径 String absolutePath=file.getAbsolutePath();//绝对路径 String fileName=file.getName();//文件（夹）名 String parentPath=file.getParent();//父目录 ###列出文件夹下的所有文件和文件夹 12File file=…… File[] fileList=file.listFiles(); ###判断是文件还是文件夹 12File file=…… boolean is=file.isDirectory();//true-是，false-否 ###判断文件（夹）是否存在 12File file=…… boolean is=file.exists();//true-是，false-否 ###新建文件（夹） 1234567891011121314151617181920212223File file=…… oolean is=file.isDirectory();//判断是否为文件夹 /*方法1*/ if(is)&#123; String path=file.getAbsolutePath(); String name=\"ABC\";//你要新建的文件夹名或者文件名 String pathx=path+name; File filex=new File(pathx); boolean is=filex.exists();//判断文件（夹）是否存在 if(!is)&#123; filex.mkdir();//创建文件夹 //filex.createNewFile();//创建文件 &#125; /*方法2*/ if(is)&#123; String path=file.getAbsolutePath(); String name=\"test.txt\";//你要新建的文件夹名或者文件名 File filex=new File(path,name);//方法1和方法2的区别在于此 boolean is=filex.exists();//判断文件（夹）是否存在 if(!is)&#123; filex.mkdir();//创建文件夹 //filex.createNewFile();//创建文件 &#125; ###重命名文件（夹） 12345File file=…… String parentPath=file.getParent(); String newName=\"name\";//重命名后的文件或者文件夹名 File filex=new File(parentPath,newName);//File filex=new File(parentPaht+newName) file.renameTo(filex); ###删除文件（夹） 123File file=…… file.delete();//立即删除 //file.deleteOnExit();//程序退出后删除，只有正常退出才会删除 原地址：Android入门之文件系统操作（二）文件操作相关指令 ###view plainprint? Android 2.3提供一个称为严苛模式（StrictMode）的调试特性 唯一一篇讲到在2.3之前要怎么处理的文章","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/wwjlife/tags/Android/"},{"name":"File","slug":"File","permalink":"https://github.com/wwjlife/tags/File/"}]}]